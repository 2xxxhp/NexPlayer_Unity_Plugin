using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#if UNITY_EDITOR_OSX
using UnityEditor;
using UnityEditor.Callbacks;
using System.IO;
#endif

/// <summary>
/// Helper class that modifies the XCode project generated by Unity to make it compatible with NexPlayer
/// </summary>
public class iOSBuild {

#if UNITY_EDITOR_OSX

	/// <summary>
	/// When Unity finishes building the XCode project this modifies it accordingly
	/// </summary>
	/// <param name="buildTarget">Build target.</param>
	/// <param name="path">Path.</param>
	[PostProcessBuild]
	public static void OnPostprocessBuild(BuildTarget buildTarget, string path) 
	{
		if (buildTarget == BuildTarget.iOS) 
		{
			// This needs to be placed in a folder named "Editor" otherwise MonoDevelop will fail to build (Not Unity)

			// That behavior is (at the time of writing this) a reported Unity issue (regression)
			// https://issuetracker.unity3d.com/issues/unity-does-not-include-unityeditor-dot-ios-dot-xcode-in-project-file

			// It can also be fixed following these steps:
			// In MonoDevelop, go under "Project" menu > "Edit References..." > ".NET Assembly" tab > Click "Browse" in lower right, and browse to your Unity install to find the dll, e.g. "/Applications/Unity/PlaybackEngines/iOSSupport/UnityEditor.iOS.Extensions.Xcode.dll"

			// Original comment:
			// ETHAN_VISUALVOCALOCT 13, 2016 22:19
			// Still happening in 5.4.2f1 for me.
			// Workaround for MonoDevelop: 
			// In MonoDevelop, go under "Project" menu > "Edit References..." > ".NET Assembly" tab > Click "Browse" in lower right, and browse to your Unity install to find the dll, e.g. "/Applications/Unity/PlaybackEngines/iOSSupport/UnityEditor.iOS.Extensions.Xcode.dll"

			Debug.Log("NexPlayer for iOS is adding changes to the build of the XCode project");

			string projectPath = path + "/Unity-iPhone.xcodeproj/project.pbxproj";

			NexPlayer.UnityEditor.iOS.Xcode.PBXProject pbxProject = new NexPlayer.UnityEditor.iOS.Xcode.PBXProject();
			pbxProject.ReadFromFile(projectPath);

			string target = pbxProject.TargetGuidByName("Unity-iPhone"); 

			// Disable bitcode
			pbxProject.SetBuildProperty(target, "ENABLE_BITCODE", "NO");

			// Add VideoToolbox
			pbxProject.AddFrameworkToProject(target, "VideoToolbox.framework", false /*not weak*/);

			// Add to other linker flags "-lstdc++"
			pbxProject.AddBuildProperty(target, "OTHER_LDFLAGS", "-lstdc++");

			pbxProject.AddBuildProperty(target, "LD_RUNPATH_SEARCH_PATHS", "$(inherited)");
			pbxProject.AddBuildProperty(target, "LD_RUNPATH_SEARCH_PATHS", "@executable_path/Frameworks");

			// In order to add properly the Embedded binaries we modified the open source file https://bitbucket.org/Unity-Technologies/xcodeapi
			pbxProject.AddDynamicFrameworkToProject (target, "Frameworks/Plugins/iOS/WidevineIntegration.framework");
			pbxProject.AddDynamicFrameworkToProject(target, "Frameworks/Plugins/iOS/widevine_cdm_sdk_release.framework");

			// Some extra needed files are not present on Unity 5.3 and below in the generated Xcode projects
			if (!NexPlayerFactory.IsUnityVersionEqualsOrAbove_5_4 ()) 
			{
				// Add the needed extra files
				CopyAndReplaceDirectory("Assets/Plugins/iOS/Unity/", Path.Combine(path, "Classes/Unity/"));
			}

			pbxProject.WriteToFile (projectPath);
		}
	}
		
	internal static void CopyAndReplaceDirectory(string srcPath, string dstPath)
	{
		// Method based on this official sampe form Unity
		// https://bitbucket.org/Unity-Technologies/iosnativecodesamples/src/ae6a0a2c02363d35f954d244a6eec91c0e0bf194/NativeIntegration/Misc/UpdateXcodeProject/Assets/Editor/XcodeProjectUpdater.cs

		// For this project the original code is slightly modified existing folders won't be deleted

		if (!Directory.Exists(dstPath))
			Directory.CreateDirectory(dstPath);
		
		if (File.Exists(dstPath))
			File.Delete(dstPath);

		foreach (var file in Directory.GetFiles(srcPath)) {
	        var destinationPath = Path.Combine (dstPath, Path.GetFileName (file));
	        if (!File.Exists(destinationPath))
		        File.Copy (file, destinationPath);
        }

		foreach (var dir in Directory.GetDirectories(srcPath))
			CopyAndReplaceDirectory(dir, Path.Combine(dstPath, Path.GetFileName(dir)));
	}

#endif
}
